إن الوضع الذي تواجهه يُعد ثغرة أمنية خطيرة — فالتطبيق يقبل أي اسم مستخدم وأي كلمة مرور، ما يعنيه أن عملية التحقق من الهوية (Authentication) مكسورة تمامًا، وقد يسمح لأي شخص بالدخول دون حاجة لتفويض أو تحقق فعلي.


---

ما هذه المشكلة من الناحية الأمنية؟

هذا النوع من الثغرات يُعرف باسم Broken Authentication أو Identification and Authentication Failure، ويُصنَّف من أبرز تهديدات أمن الويب — وفقًا لمؤسسة OWASP.

ما خطورة هذا الأمر؟

أي زائر يمكنه الدخول باستخدام بيانات عشوائية.

اختراق بيانات المستخدمين، والتصيّد، والقرصنة، وحتى التعدي على الأنظمة الأخرى المرتبطة بالتطبيق.

لا يوجد تحقق فعلي من بيانات تسجيل الدخول، ما ينتهك أساسيات الأمن الرقمي.



---

كيف يمكن حل هذه المشكلة؟ بعض خطوات الإصلاح الأساسية:

1. التأكد من آلية التحقق في السيرفر:

يجب أن يحصل المستخدم على إمكانية الدخول فقط إذا كانت البريد الإلكتروني موجودًا في قاعدة البيانات وكلمة المرور (بعد التشفير أو التجزئة) تطابق ما تم تخزينه:

عند التسجيل يجب تخزين الهاش لكلمة المرور، وليس النصّ نفسه.

عند تسجيل الدخول، يُجرى مقارنة هاش المُدخل بالهش المُخزن.


2. التحقق من الكود:

إذا كان الكود البرمجي مستثنيًا دائمًا عملية التحقق (مثلاً: if (true) return user;) أو فيه خطأ في شروط if, تأكد من مراجعة المنطق بدقة.

3. الاستفادة من مكتبات موثوقة:

أفضل تجنّب كتابة التحقق من كلمة المرور يدويًا. استخدم مكتبات معروفة مثل Passport، Devise، أو لنطاقات معينة مثل Laravel Auth أو Symfony Security.

4. تعزيز الأمان بعد التحقق:

التحقق بعاملين (2FA): يضيف طبقة أمان فوق اسم المستخدم وكلمة المرور.

الحد من محاولات الدخول (Throttling أو Lockout): يقي من هجمات القوة العنيفة (Brute-force).

تسجيل المحاولات المشبوهة وتنبيه المسؤول عند تجاوز عدد معين من المحاولات الفاشلة.



---

مثال عملي: كيف يمكنك كتابة endpoint تسجيل دخول صحيح (مثال باستخدام Express.js)

const bcrypt = require('bcrypt');
const users = require('./models/users'); // افتراض وجود نموذج للمستخدمين

app.post("/api/login", async (req, res) => {
  const { email, password } = req.body;

  // البحث عن المستخدم بناءً على البريد الإلكتروني
  const user = await users.findOne({ email });
  if (!user) {
    return res.status(401).json({ message: "بيانات الدخول خاطئة" });
  }

  // مقارنة كلمة المرور المخزنة (hash) مع ما أدخله المستخدم
  const match = await bcrypt.compare(password, user.passwordHash);
  if (!match) {
    return res.status(401).json({ message: "بيانات الدخول خاطئة" });
  }

  // تنفيذ إنشاء session أو إصدار JWT
  const token = generateJwtForUser(user.id);
  res.json({ success: true, token });
});

المفتاح: يجب أن يكون bcrypt.compare() هو المعيار الأساسي في التحقق، لا يمكن تجاوز هذا الجزء بأي شرط ثابت.



---

ماذا يمكنك أن تفعل الآن؟

راجع مسار تسجيل الدخول Login route وتأكد من أن هناك تحققًا فعليًا من البيانات.

افحص قاعدة البيانات: هل تُخزن كلمات المرور مشفّرة (hashed) فعليًا؟

احتجز حالات الدخول غير المصرح بها وتحقق من وجود محاولات دخول باستخدام كلمات مرور عشوائية.

فعّل إجراءات أمان إضافية: 2FA، تدخل بعد عدد معين من المحاولات، إلخ.


إذا أرسلت لي الكود الخاص بالتحقق أو طريقة تسجيل الدخول، أستطيع أن أساعدك في تحديد مكان الخطأ وتقديم تحسينات مباشرة.

