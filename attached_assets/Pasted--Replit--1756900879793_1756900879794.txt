رائع — جهّزت لك **نص/أمر متكامل** يمكن لوكيل ذكي على Replit (أو لأي سكربت تشغيل آلي) أن ينشئ ملفّات، يكتب أكواد، وينفّذ فحصًا عميقًا لتطبيقك في بيئة Replit وبيئة الإنتاج على Vercel. الصيغة التالية تحتوي على:
 
 
- سكربت باش واحد (`audit.sh`) ينفّذ سلسلة فحوصات عامة (مساحة، صلاحيات، بناء، لِنْت، اختبارات، تجميع، بحث عن أخطاء معروفة).
 
- ملف Node صغير (`check_endpoints.js`) لاختبار الـ API endpoints والتأكد أن الاستجابات من نوع Array/Object كما تتوقع.
 
- أوامر لـ Vercel CLI للحصول على لوجز ونشر/تفقد الإعدادات (تتطلّب `VERCEL_TOKEN`).
 
- نص إرشادي للوكيل: ماذا يفعل خطوة بخطوة، وأين يرفع النتائج (ملف `audit-report.txt` و/أو commit إلى git).
 

 
 
ملاحظة أمان: لا تشغّل هذا السكربت دون أن تكون على علم بالـ env variables الحساسة (مثل `VERCEL_TOKEN`، `AUTH_TOKEN`, أو بيانات اعتماد). احفظها في متغيرات بيئية داخل Replit ولا تضعها نصًا داخل السكربت.
 
  
# الأمر/الملفات التي أنشئها للوكيل
 
 
1. **إنشاء ملف `audit.sh`** — انسخ المحتوى التالي إلى ملف `audit.sh` في جذر المشروع واجعل الملف قابلًا للتنفيذ (`chmod +x audit.sh`):
 

 `#!/usr/bin/env bash set -euo pipefail LOGFILE="./audit-report.txt" echo "=== Audit started: $(date -u) ===" > "$LOGFILE"  echo "# 1. Basic environment info" | tee -a "$LOGFILE" echo "User: $(whoami)" | tee -a "$LOGFILE" echo "Node: $(node -v 2>/dev/null || echo 'node not found')" | tee -a "$LOGFILE" echo "NPM/Yarn: $(npm -v 2>/dev/null || echo 'npm not found')" | tee -a "$LOGFILE" echo "Disk usage (df -h):" | tee -a "$LOGFILE" df -h | tee -a "$LOGFILE" echo "Project size (du -sh .):" | tee -a "$LOGFILE" du -sh . 2>/dev/null | tee -a "$LOGFILE"  echo -e "\n# 2. Git status" | tee -a "$LOGFILE" git status --porcelain --untracked-files=all | tee -a "$LOGFILE" || true git rev-parse --abbrev-ref HEAD 2>/dev/null | tee -a "$LOGFILE" || true  echo -e "\n# 3. Clean caches (safe)" | tee -a "$LOGFILE" echo "npm cache verify (or clean if older npm)" | tee -a "$LOGFILE" npm cache verify 2>/dev/null | tee -a "$LOGFILE" || echo "npm cache verify failed" | tee -a "$LOGFILE"  echo -e "\n# 4. Remove and reinstall node_modules (optional if disk issues)" | tee -a "$LOGFILE" if [ -d "node_modules" ]; then   du -sh node_modules 2>/dev/null | tee -a "$LOGFILE"   echo "Removing node_modules to recover space (you can skip this)..." | tee -a "$LOGFILE"   rm -rf node_modules fi echo "Installing dependencies..." | tee -a "$LOGFILE" npm install --legacy-peer-deps 2>&1 | tee -a "$LOGFILE" || { echo "npm install failed" | tee -a "$LOGFILE"; exit 1; }  echo -e "\n# 5. Lint & Type-check" | tee -a "$LOGFILE" if command -v npm >/dev/null 2>&1 && npm run -s lint >/dev/null 2>&1; then   echo "Running npm run lint..." | tee -a "$LOGFILE"   npm run lint 2>&1 | tee -a "$LOGFILE" || true else   echo "No lint script or lint failed to run (skip)..." | tee -a "$LOGFILE" fi  if [ -f "tsconfig.json" ]; then   echo "Running TypeScript check (tsc --noEmit)..." | tee -a "$LOGFILE"   npx tsc --noEmit 2>&1 | tee -a "$LOGFILE" || true fi  echo -e "\n# 6. Build (simulate production build)" | tee -a "$LOGFILE" if grep -q '"build"' package.json 2>/dev/null; then   echo "Running npm run build..." | tee -a "$LOGFILE"   npm run build 2>&1 | tee -a "$LOGFILE" || { echo "Build failed - capture error" | tee -a "$LOGFILE"; } else   echo "No build script in package.json" | tee -a "$LOGFILE" fi  echo -e "\n# 7. Search for common runtime errors in built assets and source" | tee -a "$LOGFILE" # Search for .find( usage in built bundles (dist, .next, build, assets) SEARCH_DIRS=("dist" ".next" "build" "public" "assets" "src") for d in "${SEARCH_DIRS[@]}"; do   if [ -d "$d" ]; then     echo "Searching in $d for occurrences of 'find(' and '.find is not a function'..." | tee -a "$LOGFILE"     grep -RIn --exclude-dir=node_modules -E "(\.find\(|find is not a function)" "$d" 2>/dev/null | tee -a "$LOGFILE" || true   fi done  echo -e "\n# 8. Check recent logs (Replit & Vercel if CLI available)" | tee -a "$LOGFILE" # Replit logs: try to read repl logs file if exists (Replit specifics vary) if [ -f "./replit.log" ]; then   echo "Tail replit.log:" | tee -a "$LOGFILE"   tail -n 200 ./replit.log | tee -a "$LOGFILE" fi  if command -v vercel >/dev/null 2>&1; then   echo "Vercel CLI detected. Running vercel whoami and recent logs (requires VERCEL_TOKEN env)..." | tee -a "$LOGFILE"   vercel whoami 2>&1 | tee -a "$LOGFILE" || true   # try fetch logs for deployment domain (set VERCEL_DEPLOYMENT or VERCEL_URL)   if [ ! -z "${VERCEL_URL-}" ]; then     echo "Fetching Vercel logs for $VERCEL_URL (last 1h)..." | tee -a "$LOGFILE"     vercel logs "$VERCEL_URL" --since 1h --limit 200 2>&1 | tee -a "$LOGFILE" || true   fi else   echo "Vercel CLI not installed. To install: npm i -g vercel" | tee -a "$LOGFILE" fi  echo -e "\n# 9. Runtime API checks (uses node script check_endpoints.js)" | tee -a "$LOGFILE" if [ -f "./check_endpoints.js" ]; then   node check_endpoints.js 2>&1 | tee -a "$LOGFILE" || true else   echo "check_endpoints.js not found, skipping endpoint checks." | tee -a "$LOGFILE" fi  echo -e "\n# 10. Final notes and suggestions" | tee -a "$LOGFILE" echo "If you saw 'find is not a function' in logs, search where you assume arrays and add guards like Array.isArray(...)." | tee -a "$LOGFILE" echo "Audit completed at: $(date -u)" | tee -a "$LOGFILE"  echo "=== Audit finished. Report saved to $LOGFILE ===" ` 
 
1. **إنشاء ملف `check_endpoints.js`** — يوفّر فحصًا لكل endpoint (تأكد من تعديل مصفوفة `endpoints` وتهيئة الـ AUTH_TOKEN إن لزم):
 

 `// check_endpoints.js // Usage: node check_endpoints.js // Ensure you set AUTH_HEADER (optional) in env: export AUTH_HEADER="Bearer <token>"  const fetch = global.fetch || require('node-fetch'); const endpoints = [   // عدّل هذه المسارات بحسب تطبيقك   { name: "projects", url: process.env.API_BASE_URL ? `${process.env.API_BASE_URL}/api/projects` : "https://your-vercel-url/api/projects" },   { name: "projects-with-stats", url: process.env.API_BASE_URL ? `${process.env.API_BASE_URL}/api/projects/with-stats` : "https://your-vercel-url/api/projects/with-stats" },   { name: "worker-types", url: process.env.API_BASE_URL ? `${process.env.API_BASE_URL}/api/worker-types` : "https://your-vercel-url/api/worker-types" } ];  (async () => {   for (const ep of endpoints) {     try {       console.log(`\nChecking ${ep.name} -> ${ep.url}`);       const headers = { "Accept": "application/json" };       if (process.env.AUTH_HEADER) headers["Authorization"] = process.env.AUTH_HEADER;       const res = await fetch(ep.url, { headers, method: "GET" });       console.log(`Status: ${res.status}`);       const text = await res.text();       let parsed;       try {         parsed = JSON.parse(text);         const type = Array.isArray(parsed) ? "Array" : (parsed === null ? "null" : typeof parsed);         console.log(`Response parsed as: ${type}`);         if (Array.isArray(parsed)) {           console.log(`Array length: ${parsed.length}`);         } else if (parsed && typeof parsed === "object") {           console.log("Keys:", Object.keys(parsed).slice(0,20));           // Heuristic: if API returns object with array inside           for (const k of Object.keys(parsed)) {             if (Array.isArray(parsed[k])) {               console.log(`Note: key '${k}' is an array (length ${parsed[k].length})`);             }           }         }       } catch (err) {         console.warn("Response not JSON or failed to parse. First 500 chars:\n", text.slice(0,500));       }     } catch (err) {       console.error(`Error fetching ${ep.url}:`, err.message || err);     }   } })(); ` 
 
قبل التشغيل: عدّل `endpoints` في `check_endpoints.js` أو حدد `API_BASE_URL` و`AUTH_HEADER` عبر متغيرات بيئية في Replit. مثال:
 
 `export API_BASE_URL="https://construction-management-f5916dkox-mr-199.vercel.app" export AUTH_HEADER="Bearer eyJ..."   # إن كان مطلوباً node check_endpoints.js `  
# نص/تعليمات للوكيل (Prompt) — نسخة جاهزة لتلصقها في وكيل Replit AI
 `مهمتك: نفّذ فحصًا عميقًا لتطبيق الويب هذا (بيئة Replit + إنتاج Vercel). الخطوات المطلوبة: 1. أنشئ ملفين كما يلي: audit.sh و check_endpoints.js (الصيغ مُدرجة في التعليمات المرفقة). 2. اجعل audit.sh قابلًا للتنفيذ، ثم شغله: ./audit.sh 3. قبل التشغيل، اضبط المتغيرات البيئية:    - API_BASE_URL (مثلاً https://construction-management-f5916dkox-mr-199.vercel.app)    - AUTH_HEADER (إذا كان مطلوبًا للتوكن)    - VERCEL_URL أو VERCEL_TOKEN إذا تودّ جلب لوجز Vercel 4. اجمع نتائج audit-report.txt وأرفقها هنا، وابحث في النتائج عن:    - أي استجابات API بها status != 200 أو returned type غير متوقع (Object بدلاً من Array).    - أي أخطاء في build أو استثناءات مثل "find is not a function".    - سجلات Disk quota / permission errors. 5. ابحث في الكود والمجمّع (dist, .next, assets) عن استخدام .find( وافحص ما إذا كانت القيمة المستخدمة Array أو Object. 6. إذا رأيت أخطاء في runtime بسبب data shape، اقترح/قم بتعديل سريع في مكان الاستخدام (مثلاً إضافة guard: Array.isArray(x) ? x.find(...) : (x.items || [])) 7. سجّل كل الأوامر التي شغّلتها والنتائج في ملف audit-report.txt، وادفع (commit) إلى فرع جديد git branch audit-report/YYYYMMDD. 8. قدّم ملخص مختصر (5 نقاط) مع أولويات الإصلاح (مثلاً: urgent: ensure /api/projects/with-stats returns Array, high: guard against null). تنبيه: لا ترسل أي tokens أو أكواد سرية علنًا — ضع نتائجك في audit-report.txt. `  